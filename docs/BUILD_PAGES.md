# Cloudflare Pages Functions Build Process (Advanced Mode)

## Overview

The `GeneratePagesFiles()` method generates the necessary JavaScript wrapper and runtime files to deploy a Go WebAssembly application as Cloudflare Pages Functions using **Advanced Mode**.

Advanced mode uses a single `_worker.js` file instead of the `/functions` directory structure. This provides full control over all incoming HTTP requests and is ideal for existing Workers or complex routing logic.

## Generated File Structure

```
pages/                         # Output directory (static assets + worker)
├── _worker.js                 # Main Pages Function entry point (Advanced Mode)
├── app.wasm                   # Generated by tinywasm
├── wasm_exec.js               # WASM execution runtime
└── runtime.mjs                # Cloudflare Pages runtime context
└── index.html                 # Optional: Your static HTML files
└── ... (other static assets)
```

## File Generation Details

### 1. `pages/_worker.js`
- **Purpose**: Main entry point for Pages Functions (Advanced Mode)
- **Location**: Must be named `_worker.js` in the output directory
- **Responsibilities**:
  - Import and initialize WASM module
  - Handle all HTTP requests
  - Route API requests to Go WASM handlers
  - Serve static assets via `env.ASSETS.fetch()`
- **Key Features**:
  - Full control over routing
  - Access to `env.ASSETS` binding for static files
  - Must use Module Worker syntax
  - When present, `/functions` directory is completely ignored
- **Template**:
```javascript
import "./wasm_exec.js";
import { createRuntimeContext, loadModule } from "./runtime.mjs";

let mod;

globalThis.tryCatch = (fn) => {
  try {
    return {
      result: fn(),
    };
  } catch (e) {
    return {
      error: e,
    };
  }
};

async function run(ctx) {
  if (mod === undefined) {
    mod = await loadModule();
  }
  const go = new Go();

  let ready;
  const readyPromise = new Promise((resolve) => {
    ready = resolve;
  });
  const instance = new WebAssembly.Instance(mod, {
    ...go.importObject,
    workers: {
      ready: () => {
        ready();
      },
    },
  });
  go.run(instance, ctx);
  await readyPromise;
}

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    // Route API requests to Go WASM handlers
    if (url.pathname.startsWith("/api/")) {
      const binding = {};
      await run(createRuntimeContext({ env, ctx, binding }));
      return binding.handleRequest(request);
    }
    
    // Serve static assets for all other requests
    // CRITICAL: Without this, static files will not be served
    return env.ASSETS.fetch(request);
  },
};
```

### 2. `pages/app.wasm`
- **Source**: Compiled by tinywasm from your Go code
- **Process**: `tinywasm.Compile()` handles this automatically
- **Location**: Same directory as `_worker.js`
- **Modes**: 
  - `c` (coding): Fast compilation with Go standard compiler
  - `d` (debug): TinyGo with debug symbols
  - `p` (production): TinyGo optimized for minimal size

### 3. `pages/wasm_exec.js`
- **Purpose**: Provides the `Go` class and WebAssembly instantiation helpers
- **Source**: Depends on compilation mode
  - Go mode: `wasm_exec_go.js` 
  - TinyGo mode: `wasm_exec_tinygo.js`
- **Content**: Runtime-provided by Go/TinyGo toolchains
- **Action**: Copy the appropriate version based on `tinywasm` current mode

### 4. `pages/runtime.mjs`
- **Purpose**: Creates the Cloudflare Pages-specific runtime context
- **Responsibilities**:
  - Import `app.wasm` module
  - Provide `loadModule()` function
  - Create `createRuntimeContext()` for Pages environment
- **Template**:
```javascript
import { connect } from "cloudflare:sockets";
import mod from "./app.wasm";

export async function loadModule() {
  return mod;
}

export function createRuntimeContext({ env, ctx, binding }) {
  return {
    env,
    ctx,
    connect,
    binding,
  };
}
```

## Implementation Steps

### Method: `GeneratePagesFiles()`

1. **Ensure output directory exists**
   ```go
   pagesDir := path.Join(g.tw.Config.AppRootDir, "pages")
   os.MkdirAll(pagesDir, os.ModePerm)
   ```

2. **Compile WASM with tinywasm**
   ```go
   // tinywasm handles app.wasm generation to pages/ directory
   // Configure tinywasm output to pages/ directory
   ```

3. **Copy wasm_exec.js**
   - Determine current tinywasm mode
   - Copy appropriate `wasm_exec_*.js` from embedded assets or tinywasm cache
   - Write to `pages/wasm_exec.js`

4. **Generate runtime.mjs**
   - Create file with Cloudflare-specific imports
   - Import `app.wasm` module (same directory)
   - Export `loadModule()` and `createRuntimeContext()`
   - Write to `pages/runtime.mjs`

5. **Generate _worker.js**
   - Create Advanced Mode worker entry point
   - Import `wasm_exec.js` and `runtime.mjs` (relative imports)
   - Implement `run()` helper function
   - Export default object with `fetch()` handler
   - Handle `/api/*` routes → Go WASM
   - Handle all other routes → `env.ASSETS.fetch()` for static files
   - Write to `pages/_worker.js`

## Configuration Requirements

The `wrangler.toml` should configure Pages deployment with Advanced Mode:

```toml
name = "my-pages-app"
compatibility_date = "2023-04-30"

# No pages_build_output_dir needed - wrangler will detect _worker.js
# No main field needed - Pages automatically uses _worker.js
```

## Advanced Mode Routing

### How Advanced Mode Works

1. **Single Entry Point**: `_worker.js` handles ALL requests
2. **Full Control**: Your code decides what gets served
3. **ASSETS Binding**: Use `env.ASSETS.fetch()` to serve static files
4. **No /functions Directory**: When `_worker.js` exists, `/functions` is ignored

### Routing Logic in _worker.js

```javascript
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    // Custom logic: API routes handled by Go WASM
    if (url.pathname.startsWith("/api/")) {
      // ... initialize WASM and handle request
      return binding.handleRequest(request);
    }
    
    // Default: Serve static assets
    // CRITICAL: This is required for static files to work
    return env.ASSETS.fetch(request);
  }
};
```

### Benefits of Advanced Mode

- ✅ **No subdirectories**: Everything in one output folder
- ✅ **Simpler structure**: No `/functions` complexity
- ✅ **Full control**: Custom routing logic in one place
- ✅ **Worker compatibility**: Easy migration from/to Workers
- ✅ **Familiar pattern**: Same as Workers deployment

## Integration with Build Process

### Example Makefile
```makefile
.PHONY: build
build:
	go run main.builder.go  # Calls goflare.GeneratePagesFiles()

.PHONY: dev
dev:
	wrangler pages dev ./pages

.PHONY: deploy
deploy:
	wrangler pages deploy ./pages
```

### Example Go Build Script (main.builder.go)
```go
package main

import (
    "log"
    "github.com/cdvelop/goflare"
)

func main() {
    g := goflare.New(&goflare.Config{
        AppRootDir:                 ".",
        WorkerDirSubRelativeOutput: "pages",  // Output to pages/ directory
        MainInputFile:              "main.go",
        Logger: func(message ...any) {
            log.Println(message...)
        },
    })
    
    if err := g.GeneratePagesFiles(); err != nil {
        log.Fatal("Failed to generate Pages files:", err)
    }
    
    log.Println("✅ Pages files generated successfully in ./pages/")
}
```

## Assets Management

GoFlare should embed the template files using `go:embed`:

```go
//go:embed assets
var assets embed.FS

const (
    assetDirPath        = "assets"
    runtimeDirPath      = "assets/runtime"
    pagesWorkerTemplate = "assets/pages/worker.js.tmpl"
)
```

Directory structure:
```
goflare/
├── assets/
│   ├── runtime/
│   │   └── cloudflare.mjs        # Runtime context template
│   └── pages/
│       └── worker.js.tmpl         # _worker.js template for Advanced Mode
```

## Differences from Workers

| Aspect | Workers | Pages (Advanced Mode) |
|--------|---------|----------------------|
| Entry Point | `worker.mjs` in deploy/ | `_worker.js` in pages/ |
| Deployment | `wrangler deploy` | `wrangler pages deploy` |
| Static Assets | Not directly supported | Via `env.ASSETS.fetch()` |
| Handler Export | `export default { fetch }` | `export default { fetch }` (same!) |
| Routing | Manual in code | Manual in code (same!) |
| Config | `main` field in wrangler.toml | Auto-detected `_worker.js` |
| ASSETS Binding | N/A | Required for static files |

## Error Handling

The method should return errors for:
- Failed directory creation
- WASM compilation errors (from tinywasm)
- File write failures
- Missing template assets
- Invalid path configurations

## Notes

### Critical Points

- **Advanced Mode**: Uses `_worker.js` instead of `/functions` directory
- **Single Output**: All files (WASM, JS, static) in one `pages/` directory
- **ASSETS Binding**: `env.ASSETS.fetch()` is REQUIRED to serve static files
- **Full Control**: Your `_worker.js` handles ALL requests
- **Module Syntax**: Must use `export default { fetch }` syntax
- **No /functions**: When `_worker.js` exists, `/functions` is completely ignored

### Best Practices

- Always fallback to `env.ASSETS.fetch(request)` for non-API routes
- Use path prefixes (e.g., `/api/*`) to separate dynamic from static content
- For production, use TinyGo mode (`p`) for minimal binary size
- Place all static HTML/CSS/JS directly in `pages/` directory
- Keep `_worker.js` logic simple - complex routing should be in Go

### Why Advanced Mode?

1. **Simpler Structure**: No nested `/functions/api/` subdirectories
2. **Better Performance**: Direct control over routing logic
3. **Worker Compatibility**: Easy to migrate code between Workers and Pages
4. **Cleaner Deployment**: All output in one directory
5. **Full Flexibility**: Complete control over request handling

## Project Structure Example

```
my-pages-app/
├── main.go                    # Your Go application
├── main.builder.go            # Build script calling goflare
├── wrangler.toml              # Cloudflare Pages configuration
├── go.mod
└── pages/                     # Output directory (deploy this)
    ├── _worker.js             # Generated by goflare (Advanced Mode)
    ├── app.wasm               # Generated by tinywasm
    ├── wasm_exec.js           # Generated by goflare
    ├── runtime.mjs            # Generated by goflare
    ├── index.html             # Your static pages
    ├── style.css              # Your styles
    └── ... (other static assets)
```

## Comparison with Standard Mode

### Standard Mode (file-based routing)
```
functions/api/[[routes]].mjs  ← Multiple files, nested structure
build/app.wasm
build/wasm_exec.js
build/runtime.mjs
pages/index.html
```

### Advanced Mode (single worker)
```
pages/_worker.js              ← Single entry point, flat structure
pages/app.wasm
pages/wasm_exec.js
pages/runtime.mjs
pages/index.html
```

**Advanced Mode is simpler and recommended for most use cases.**
