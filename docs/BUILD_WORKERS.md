# Cloudflare Workers Build Process

## Overview

The `GenerateWorkerFiles()` method generates the necessary JavaScript wrapper and runtime files to deploy a Go WebAssembly application as a Cloudflare Worker.

## Generated File Structure

```
deploy/
├── app.wasm              # Generated by tinywasm (Go compiled to WASM)
├── wasm_exec.js          # WASM execution runtime (mode-specific)
├── runtime.mjs           # Cloudflare-specific runtime context
└── worker.mjs            # Main worker entry point
```

## File Generation Details

### 1. `app.wasm`
- **Source**: Compiled by tinywasm from your Go code
- **Process**: `tinywasm.Compile()` handles this automatically
- **Modes**: 
  - `c` (coding): Fast compilation with Go standard compiler
  - `d` (debug): TinyGo with debug symbols
  - `p` (production): TinyGo optimized for minimal size

### 2. `wasm_exec.js`
- **Purpose**: Provides the `Go` class and WebAssembly instantiation helpers
- **Source**: Depends on compilation mode
  - Go mode: `wasm_exec_go.js` 
  - TinyGo mode: `wasm_exec_tinygo.js`
- **Content**: Runtime-provided by Go/TinyGo toolchains
- **Action**: Copy the appropriate version based on `tinywasm` current mode

### 3. `runtime.mjs`
- **Purpose**: Creates the Cloudflare-specific runtime context
- **Responsibilities**:
  - Import `app.wasm` module
  - Provide `loadModule()` function
  - Create `createRuntimeContext()` with Cloudflare APIs
- **Template**:
```javascript
import { connect } from "cloudflare:sockets";
import mod from "./app.wasm";

export async function loadModule() {
  return mod;
}

export function createRuntimeContext({ env, ctx, binding }) {
  return {
    env,
    ctx,
    connect,
    binding,
  };
}
```

### 4. `worker.mjs`
- **Purpose**: Main entry point for Cloudflare Worker
- **Responsibilities**:
  - Import `wasm_exec.js` and `runtime.mjs`
  - Initialize WebAssembly instance with proper imports
  - Export handlers: `fetch`, `scheduled`, `queue`
- **Template**:
```javascript
import "./wasm_exec.js";
import { createRuntimeContext, loadModule } from "./runtime.mjs";

let mod;

globalThis.tryCatch = (fn) => {
  try {
    return {
      result: fn(),
    };
  } catch (e) {
    return {
      error: e,
    };
  }
};

async function run(ctx) {
  if (mod === undefined) {
    mod = await loadModule();
  }
  const go = new Go();

  let ready;
  const readyPromise = new Promise((resolve) => {
    ready = resolve;
  });
  const instance = new WebAssembly.Instance(mod, {
    ...go.importObject,
    workers: {
      ready: () => {
        ready();
      },
    },
  });
  go.run(instance, ctx);
  await readyPromise;
}

async function fetch(req, env, ctx) {
  const binding = {};
  await run(createRuntimeContext({ env, ctx, binding }));
  return binding.handleRequest(req);
}

async function scheduled(event, env, ctx) {
  const binding = {};
  await run(createRuntimeContext({ env, ctx, binding }));
  return binding.runScheduler(event);
}

async function queue(batch, env, ctx) {
  const binding = {};
  await run(createRuntimeContext({ env, ctx, binding }));
  return binding.handleQueueMessageBatch(batch);
}

export default {
  fetch,
  scheduled,
  queue,
};
```

## Implementation Steps

### Method: `GenerateWorkerFiles()`

1. **Ensure output directory exists**
   ```go
   outputDir := path.Join(g.tw.Config.AppRootDir, g.tw.Config.RelativeOutputDirectory)
   os.MkdirAll(outputDir, os.ModePerm)
   ```

2. **Compile WASM with tinywasm**
   ```go
   // tinywasm handles app.wasm generation
   // This is already configured in goflare.New()
   ```

3. **Copy wasm_exec.js**
   - Determine current tinywasm mode
   - Copy appropriate `wasm_exec_*.js` from embedded assets or tinywasm cache
   - Write to `{outputDir}/wasm_exec.js`

4. **Generate runtime.mjs**
   - Create file with Cloudflare-specific imports
   - Import `app.wasm` module
   - Export `loadModule()` and `createRuntimeContext()`
   - Write to `{outputDir}/runtime.mjs`

5. **Generate worker.mjs**
   - Create main worker entry point
   - Import `wasm_exec.js` and `runtime.mjs`
   - Implement `run()` helper function
   - Export handler functions: `fetch`, `scheduled`, `queue`
   - Write to `{outputDir}/worker.mjs`

## Configuration Requirements

The `wrangler.toml` or `wrangler.jsonc` should reference the generated worker:

```toml
name = "my-worker"
main = "./deploy/worker.mjs"
compatibility_date = "2023-04-30"
```

## Integration with Build Process

### Example Makefile
```makefile
.PHONY: build
build:
	go run main.go  # Calls goflare.GenerateWorkerFiles()

.PHONY: dev
dev:
	wrangler dev

.PHONY: deploy
deploy:
	wrangler deploy
```

### Example Go Code
```go
package main

import "github.com/cdvelop/goflare"

func main() {
    g := goflare.New(&goflare.Config{
        AppRootDir:                 ".",
        RelativeOutputDirectory: "deploy",
        MainInputFile:              "main.worker.go",
    })
    
    if err := g.GenerateWorkerFiles(); err != nil {
        panic(err)
    }
}
```

## Assets Management

GoFlare should embed the template files using `go:embed`:

```go
//go:embed assets
var assets embed.FS

const (
    assetDirPath   = "assets"
    runtimeDirPath = "assets/runtime"
    commonDirPath  = "assets/common"
)
```

Directory structure:
```
goflare/
├── assets/
│   ├── runtime/
│   │   └── cloudflare.mjs
│   └── common/
│       └── worker.mjs
```

## Error Handling

The method should return errors for:
- Failed directory creation
- WASM compilation errors (from tinywasm)
- File write failures
- Missing template assets

## Notes

- The `wasm_exec.js` file content changes based on compilation mode
- For production builds, ensure TinyGo mode is used for minimal binary size
- The `worker.mjs` file is runtime-agnostic and can be reused across projects
- All generated files should be created atomically to avoid partial deployments
